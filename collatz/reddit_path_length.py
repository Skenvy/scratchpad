# https://www.reddit.com/r/Collatz/comments/1i7nb7q/third_weekly_collatz_path_length_competition/

BITS_THIS_WEEK = 256
# Samples to try should actually be "half" how many you want because it will try one less and one more than the magic numbers
SAMPLES_TO_TRY = 5000
# Maximum stopping time to check for each before giving up
MST=10000
# The post includes a baseline stopping time to beat (here as the total stopping time)
ST2B = 3035

BIT_MIN = 2**(BITS_THIS_WEEK - 1)
BIT_MAX = 2*BIT_MIN - 1

MAGIC_BASE = 576460752303423488
MAGIC_ADD = 27

def magic(n):
    return MAGIC_ADD+MAGIC_BASE*n

# Get the first and last "n" such that magic(n) will be between BIT_MIN and BIT_MAX
_REM = BIT_MIN % MAGIC_BASE
FIRST_VAL = BIT_MIN - _REM + MAGIC_BASE
FIRST_INDEX = FIRST_VAL // MAGIC_BASE

_REM = BIT_MAX % MAGIC_BASE
LAST_VAL = BIT_MAX - _REM - (_REM<MAGIC_ADD)*MAGIC_BASE
LAST_INDEX = LAST_VAL // MAGIC_BASE

from math import ceil as roof

# To take "SAMPLES_TO_TRY"*2 samples, walk out of range
i = FIRST_INDEX # index
u = (LAST_INDEX - FIRST_INDEX)/SAMPLES_TO_TRY # update
ui = 0 # update's iteration

from collatz import stopping_time, hailstone_sequence

if __name__ == '__main__':
    print(f'Bits this week are {BITS_THIS_WEEK} -- range is')
    print(f'FROM: {BIT_MIN}')
    print(f'TO:   {BIT_MAX}')
    print(f'Indexing from {FIRST_INDEX} to {LAST_INDEX}')
    l = {}
    while i < LAST_INDEX+1:
        _m = magic(i)
        _ml = _m - 1
        _mh = _m + 1
        l[_ml] = stopping_time(_ml, total_stopping_time=True, max_stopping_time=MST) or -1
        l[_mh] = stopping_time(_mh, total_stopping_time=True, max_stopping_time=MST) or -1
        ui += 1
        i = FIRST_INDEX + roof(u*ui)
    # Now order so the longest times are printed last
    sl = {k:v for k,v in sorted(l.items(), key=lambda item: item[1])}
    for (k,v) in sl.items():
        print(f'{"BEATS THE ST2B"*(v>ST2B)+"LESS THAN ST2B"*(v<=ST2B)}: NUMBER {k} HAS STOPPING TIME {v}')
    print()
    print(f'Checked a total of {len(sl)} numbers')
else:
    print('Use generating_index(n) and how_many_unique_stops(n)')

def generating_index(n):
    return (n-MAGIC_ADD)//MAGIC_BASE

# Assumes you know that the MST is enough to capture the whole sequence
def how_many_unique_stops(n):
    _m = magic(n)
    hl = hailstone_sequence(_m-1, max_total_stopping_time=MST)
    hh = hailstone_sequence(_m+1, max_total_stopping_time=MST)
    if hl[-1][1] != hh[-1][1]:
        min_len = min(hl[-1][1], hh[-1][1])
        max_len = max(hl[-1][1], hh[-1][1])
        hmin = hl if hl[-1][1] == min_len else hh
        hmax = hh if hl[-1][1] == min_len else hl
        prfmin = "-" if hl[-1][1] == min_len else "+"
        prfmax = "+" if hl[-1][1] == min_len else "-"
        for i in range(min_len):
            if hmin[i] in hmax:
                # "i" is the amount of unique values in hmin
                print(f'The sequences generated by {_m}±1 have different lengths, {hl[-1][1]} and {hh[-1][1]}. The {prfmin}1 shortest path has {i-1} unique values before landing on the shared path starting from {hmin[i]}, which has {min_len-i} total stopping time, meaning there are {min_len-i+1} shared values, and the {prfmax}1 longest path has {max_len-min_len+i-1} unique values')
                return
    for i in range(hl[-1][1]):
        if hl[i] == hh[i]:
            print(f'The sequences generated by {_m}±1 have the same length {hl[-1][1]}, with {i-1} unique initial values and share a sequence of length {hl[-1][1]-i+1}')
            return

